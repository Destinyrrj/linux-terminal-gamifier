#!/bin/bash

# =============================
# Linux Terminal Gamifier v1.6
# =============================
# This script gamifies your terminal by tracking experience points and levels
# based on the number of commands you execute. Newly found commands give more exp,
# repeated commands less, wrong commands still give a little. At least you tried.
#
# Setup for bash:
# 1. Save this file in your home directory
#        curl --output ~/gamifier "https://raw.githubusercontent.com/Divinux/linux-terminal-gamifier/refs/heads/main/gamifier"
# 2. Source the file in your bashrc. This can be done manually or by running
#        echo 'source ~/gamifier' >> ~/.bashrc
# 3. Ensure your history is reloaded after each command, then call update_exp
#    If you have not yet modified your PROMPT_COMMAND, you can simply run
#        echo 'export PROMPT_COMMAND="history -a; history -n; update_exp; $PROMPT_COMMAND"' >> ~/.bashrc
# 4. Restart your terminal or run
#        source ~/.bashrc
#
# Setup for zsh:
# 1. Save this file in your home directory
#        curl --output ~/gamifier "https://raw.githubusercontent.com/Divinux/linux-terminal-gamifier/refs/heads/main/gamifier"
# 2. Source the file in your zshrc. This can be done manually or by running
#        echo 'source ~/gamifier' >> ~/.zshrc
# 3. Ensure your history is reloaded after each command, then call update_exp
#    If you have not yet modified your precmd hook, you can simply run
#        echo -e "setopt incappendhistory\nprecmd() { update_exp; }" >> ~/.zshrc
# 4. Restart your terminal or run
#        source ~/.zshrc
#
# Setup for fish:
# 1. Save this file in your home directory
#        curl --output ~/gamifier "https://raw.githubusercontent.com/Divinux/linux-terminal-gamifier/refs/heads/main/gamifier"
# 2. Source the file in your fish config. This can be done manually or by running
#        echo 'source ~/gamifier' >> ~/.config/fish/config.fish
# 3. Add a function to run update_exp after each command using fish event system
#        echo 'function --on-event fish_postexec; update_exp; end' >> ~/.config/fish/config.fish
# 4. Restart your terminal or run
#        source ~/.config/fish/config.fish
#
# Setup for PowerShell (v2-7):
# 1. Save this file in your PowerShell profile directory
#        Invoke-WebRequest -Uri "https://raw.githubusercontent.com/Divinux/linux-terminal-gamifier/refs/heads/main/gamifier" -OutFile "$HOME\gamifier"
# 2. Create or update your PowerShell profile to source the file
#        if (!(Test-Path -Path $PROFILE)) { New-Item -ItemType File -Path $PROFILE -Force }
#        Add-Content -Path $PROFILE -Value ". `$HOME\gamifier"
# 3. Add a function to your profile to run update_exp after each command
#        Add-Content -Path $PROFILE -Value "function prompt { update_exp; return '`PS> ' }"
# 4. Restart PowerShell or reload your profile
#        . $PROFILE
# Note: In PowerShell, some commands like 'checkrank', 'checkstats', etc. may conflict with existing
#       PowerShell commands. If this happens, the script will automatically create aliases with the
#       prefix 'ltg_' (e.g., 'ltg_checkrank', 'ltg_checkstats', etc.).
#
# Additional info:
# 1. This script creates a directory under $XDG_DATA_HOME (defaults to ~/.local/share/ and uses it as a
#    fallback if $XDG_DATA_HOME is not set) with four additional files:
#        .exp is used to track the current experience amount and level
#        .usedcommands contains all commands the user used so far
#        .achievements tracks the status of all achievements
#        .streak tracks the daily usage streak
#    To continue tracking your progress on a new install, just copy this directory over to it.
# 2. You may want to increase your HISTSIZE and HISTFILESIZE.
#    Setting them to nothing, i.e. "HISTSIZE=" and "HISTFILESIZE=" makes them unlimited
# 3. You can use checkrank at any time to check your current progress.
# 4. Use checkstats to display usage stats.
# 5. Use ghelp to display a short info message.
# 6. Use gupdate to update Linux Terminal Gamifier.
#
# Uninstall:
# 1. Remove 'source ~/gamifier' and update_exp; from your bashrc, or if using zsh
#    remove 'source ~/gamifier', 'setopt incappendhistory' and precmd() { update_exp; } from your .zshrc,
#    or if using fish remove 'source ~/gamifier' and 'function --on-event fish_postexec; update_exp; end' from ~/.config/fish/config.fish,
#    or if using PowerShell remove the lines you added to your $PROFILE that reference gamifier
# 2. Delete the gamifier file, and the ~/.local/share/gamifier directory (or ~/AppData/Local/gamifier on Windows)
# 3. Restart your terminal
#
# Copyright (c) 2025 Divinux
# Licensed under the MIT License - see the LICENSE file for details.

# Define save directory
SAVE_DIR="${XDG_DATA_HOME:-$HOME/.local/share}/gamifier"
mkdir -p "$SAVE_DIR"

# Create save files
exp_file="$SAVE_DIR/.exp"
used_commands_file="$SAVE_DIR/.usedcommands"
achievements_file="$SAVE_DIR/.achievements"
streak_file="$SAVE_DIR/.streak"

# Notification settings
notify_on_new=true
notify_on_reused=false
notify_on_false_new=true
notify_on_false_reused=false

# Custom messages
msg_new_command="New command discovered!"
msg_repeat_command="Experience gained!"
msg_false_new_command="Incorrect command! At least you tried!"
msg_false_repeat_command="Trying incorrect command again..."

# EXP settings
exp_new_command=3
exp_reused_command=2
exp_false_new_command=1
exp_false_reused_command=0

# EXP curve
exp_increase_percent=6
exp_base=30

# Initialize .exp file if it doesn't exist
if [ ! -f "$exp_file" ]; then
    echo "EXP=0" > "$exp_file"
    echo "LVL=1" >> "$exp_file"
    echo "TOTAL_COMMANDS=0" >> "$exp_file"
fi

# Initialize .usedcommands file if it doesn't exist
if [ ! -f "$used_commands_file" ]; then
    touch "$used_commands_file"
fi

# Initialize .streak file if it doesn't exist
if [ ! -f "$streak_file" ]; then
    echo "last_date_used=$(date +%Y-%m-%d)" > "$streak_file"
    echo "streak=1" >> "$streak_file"
fi

# Detect shell
SHELL_NAME=$(ps -p $$ -o comm= 2>/dev/null || echo $0)

# Handle PowerShell detection
if [[ "$SHELL_NAME" == *"pwsh"* ]] || [[ "$SHELL_NAME" == *"powershell"* ]]; then
    IS_POWERSHELL=true
    POWERSHELL_VERSION=$(powershell -NoProfile -Command '$PSVersionTable.PSVersion.Major' 2>/dev/null || echo "0")
    
    # Check if running on Windows or Unix-like
    if [[ "$OSTYPE" == "msys" ]] || [[ "$OSTYPE" == "win32" ]] || [[ "$OSTYPE" == "cygwin" ]]; then
        IS_WINDOWS=true
        # Adjust save directory for Windows if needed
        if [[ -z "$XDG_DATA_HOME" ]]; then
            SAVE_DIR="$HOME/AppData/Local/gamifier"
        fi
    fi
else
    IS_POWERSHELL=false
    IS_WINDOWS=false
fi

# Determine history file location
case "$SHELL_NAME" in
    bash)
		# if the variable HISTFILE is set, use it, otherwise default to .bash_history
		if [[ -n "$HISTFILE" ]]; then
            histfile="$HISTFILE"
        else
			histfile="$HOME/.bash_history"
		fi
        ;;
    zsh)
		# if the variable HISTFILE is set, use it, otherwise check for the most current default and use that
        if [[ -n "$HISTFILE" ]]; then
            histfile="$HISTFILE"
        else
            zsh_history_files=("$HOME/.histfile" "$HOME/.zsh_history")
            latest=$(ls -t "${ZSH_HISTORY_FILES[@]}" 2>/dev/null | head -n 1)
            histfile="${latest:-$HOME/.histfile}"
        fi
        ;;
    fish)
        # Fish stores history in a different format
        histfile="$HOME/.local/share/fish/fish_history"
        ;;
    *pwsh*|*powershell*)
        # PowerShell doesn't use a simple history file, we'll use a different approach
        if [ "$IS_WINDOWS" = true ]; then
            # PowerShell on Windows
            if [ "$POWERSHELL_VERSION" -ge 7 ]; then
                # PS7+ on Windows
                histfile="$HOME/AppData/Roaming/Microsoft/Windows/PowerShell/PSReadLine/ConsoleHost_history.txt"
            else
                # PS2 to PS5.1 on Windows
                histfile="$HOME/AppData/Roaming/Microsoft/Windows/PowerShell/PSReadLine/ConsoleHost_history.txt"
            fi
        else
            # PowerShell on Linux/macOS
            if [ "$POWERSHELL_VERSION" -ge 7 ]; then
                # PS7+ on Linux/macOS
                histfile="$HOME/.local/share/powershell/PSReadLine/ConsoleHost_history.txt"
            else
                # Older PowerShell on Linux is less common
                histfile="$HOME/.local/share/powershell/PSReadLine/ConsoleHost_history.txt"
            fi
        fi
        ;;
	*)
		# if the variable HISTFILE is set, use it, otherwise just error output
		# this happens when ps fails
		if [[ -n "$HISTFILE" ]]; then
            histfile="$HISTFILE"
        else
			echo "History file could not be found. Please set the $HISTFILE variable."
		fi
        ;;
esac

# Initialize achievements file if it doesn't exist
if [ ! -f "$achievements_file" ]; then
    cat <<EOF > "$achievements_file"
Bootstrapped:Use 5 unique commands:5:unique:LOCKED
Init Process:Use 10 unique commands:10:unique:LOCKED
System Call:Use 15 unique commands:15:unique:LOCKED
Interrupt Handler:Use 20 unique commands:20:unique:LOCKED
Overclocked:Use 25 unique commands:25:unique:LOCKED
Firmware Flash:Use 30 unique commands:30:unique:LOCKED
Pull Request:Use 40 unique commands:40:unique:LOCKED
Memory Leak:Use 50 unique commands:50:unique:LOCKED
Merge Conflict:Use 75 unique commands:75:unique:LOCKED
Infinite Rebase:Use 100 unique commands:100:unique:LOCKED
Segfault:Use 125 unique commands:125:unique:LOCKED
Cherry-Picked:Use 150 unique commands:150:unique:LOCKED
Force Push:Use 200 unique commands:200:unique:LOCKED
Fork Bomb:Use 250 unique commands:250:unique:LOCKED
Detached HEAD:Use 350 unique commands:350:unique:LOCKED
Kernel Panic:Use 500 unique commands:500:unique:LOCKED
First Steps:Use 10 commands total:10:total:LOCKED
Tentative Exploration:Use 20 commands total:20:total:LOCKED
Getting Comfortable:Use 30 commands total:30:total:LOCKED
Confidence Rising:Use 40 commands total:40:total:LOCKED
Settling In:Use 50 commands total:50:total:LOCKED
Building Momentum:Use 100 commands total:100:total:LOCKED
Familiar Ground:Use 250 commands total:250:total:LOCKED
Flow State Achieved:Use 500 commands total:500:total:LOCKED
In the Zone:Use 750 commands total:750:total:LOCKED
Unshakable Rhythm:Use 1000 commands total:1000:total:LOCKED
Second Nature:Use 2500 commands total:2500:total:LOCKED
Beyond Muscle Memory:Use 5000 commands total:5000:total:LOCKED
Terminal Nirvana:Use 10000 commands total:10000:total:LOCKED
Superuser:Run a command with sudo:sudo:command:LOCKED
Explorer:List files in a directory:ls:command:LOCKED
Nomad:Change directories:cd:command:LOCKED
Pathfinder:Display the current directory:pwd:command:LOCKED
Creator:Create a new file:touch:command:LOCKED
Architect:Create a new directory:mkdir:command:LOCKED
Destroyer:Delete a file:rm:command:LOCKED
Cleaner:Remove a directory:rmdir:command:LOCKED
Duplicator:Copy a file:cp:command:LOCKED
Transporter:Move or rename a file:mv:command:LOCKED
System Seer:View system information:uname:command:LOCKED
Survivor:Check system uptime:uptime:command:LOCKED
Space Navigator:Show disk space usage:df:command:LOCKED
Memory Master:Display RAM usage:free:command:LOCKED
Identity Crisis:Show current user:whoami:command:LOCKED
Gatekeeper:Change file permissions:chmod:command:LOCKED
Puppeteer:Change file ownership:chown:command:LOCKED
Process Watcher:View active processes:ps:command:LOCKED
Terminator:Kill a process:kill:command:LOCKED
Taskmaster:Monitor system tasks:top:command:LOCKED
Echo Seeker:Check network connection:ping:command:LOCKED
Data Hunter:Download a file from the web:wget:command:LOCKED
Web Whisperer:Fetch data from a URL:curl:command:LOCKED
Reader:Display a file's contents:cat:command:LOCKED
Scribe:Edit a file with nano:nano:command:LOCKED
Wizard:Edit a file with Vim:vim:command:LOCKED
Scholar:Read the manual:man:command:LOCKED
Performance Guru:Run btop:btop:command:LOCKED
Resource Watcher:Run htop:htop:command:LOCKED
Process Spy:Run pidof:pidof:command:LOCKED
System Analyst:Run vmstat:vmstat:command:LOCKED
Kernel Inspector:Run dmesg:dmesg:command:LOCKED
Log Seeker:Run journalctl:journalctl:command:LOCKED
Matrix Coder:Run cmatrix:cmatrix:command:LOCKED
Digital Botanist:Run bonsai:bonsai:command:LOCKED
ASCII Artist:Run figlet:figlet:command:LOCKED
Color Wizard:Run lolcat:lolcat:command:LOCKED
Hacker Mode:Run sl (Steam Locomotive):sl:command:LOCKED
Curiosity:Check Gamifier Stats:checkstats:command:LOCKED
Patience:Check Gamifier Level:checkrank:command:LOCKED
You'll Never Walk Alone:Check Gamifier Infopage:ghelp:command:LOCKED
Come back soon!:2 day streak:2:streak:LOCKED
Repeat Offender:3 day streak:3:streak:LOCKED
Business Week:5 day streak:5:streak:LOCKED
24/7:Use the terminal daily for a week:7:streak:LOCKED
It's Been Two Weeks:Use the terminal daily for two weeks:14:streak:LOCKED
Can't Stop Won't Stop:Use the terminal daily for a month:30:streak:LOCKED
Seasonal Employee:Use the terminal daily for three months:60:streak:LOCKED
Server-grade Dedication:Use the terminal daily for an entire year:365:streak:LOCKED
EOF
fi

# Check for PowerShell command conflicts if running in PowerShell
if [ "$IS_POWERSHELL" = true ]; then
    # Run this after all functions are defined
    check_powershell_execution_policy
    check_powershell_command_conflicts
fi

# Function to get the current EXP
get_exp() {
    grep "EXP=" "$exp_file" | cut -d'=' -f2
}

# Function to set EXP
set_exp() {
    crossplatform_sed_inplace "s/^EXP=.*/EXP=$1/" "$exp_file"
}

# Function to get the current LVL
get_lvl() {
    grep "LVL=" "$exp_file" | cut -d'=' -f2
}

# Function to determine EXP required for next level
exp_needed_for_level() {
    local lvl=$(get_lvl)

    if [ "$lvl" -eq 1 ]; then
        echo "$exp_base"
    else
        echo $(echo "$exp_base * (($exp_increase_percent + 100) ^ ($lvl - 1)) / (100 ^ ($lvl - 1))" | bc)
    fi
}

# Function to level up if needed
level_up() {
    local exp=$(get_exp)
    local lvl=$(get_lvl)
    local needed=$(exp_needed_for_level)

    while [ "$exp" -ge "$needed" ]; do
        new_lvl=$((lvl + 1))
        level_up_message "$new_lvl"
        set_exp "$new_lvl"
        exp=$((exp - needed))
        needed=$(exp_needed_for_level)
        lvl=$new_lvl
    done
    set_exp "$exp"
}

# Function to unlock achievements
check_achievements() {
    local total_commands=$(awk -F'=' '/TOTAL_COMMANDS=/ {print $2}' "$exp_file")
    local unique_commands=$(wc -l < "$used_commands_file")
    local last_command=$1
    local streak=$(grep "streak=" "$streak_file" | cut -d'=' -f2)

    local updates=()
    while IFS=: read -r name description requirement type astatus; do
        if [ "$astatus" = "LOCKED" ]; then
            local unlock=false

            case "$type" in
                unique)
                    [ "$unique_commands" -ge "$requirement" ] && unlock=true
                    ;;
                total)
                    [ "$total_commands" -ge "$requirement" ] && unlock=true
                    ;;
                command)
                    [ "$first_word" = "$requirement" ] && unlock=true
                    ;;
                streak)
                    [ "$streak" -ge "$requirement" ] && unlock=true
                    ;;
            esac

            if [ "$unlock" = true ]; then
                echo "Achievement Unlocked: $name - $description!"
                # Escape special characters in sed pattern
                local escaped_name=$(echo "$name" | sed 's/[\/&]/\\&/g')
                local escaped_desc=$(echo "$description" | sed 's/[\/&]/\\&/g')
                local escaped_req=$(echo "$requirement" | sed 's/[\/&]/\\&/g')
                local escaped_type=$(echo "$type" | sed 's/[\/&]/\\&/g')
                updates+=("$escaped_name:$escaped_desc:$escaped_req:$escaped_type:LOCKED")
            fi
        fi
    done < "$achievements_file"

    # Apply updates one by one to avoid sed syntax errors
    for entry in "${updates[@]}"; do
        crossplatform_sed_inplace "s/^$entry/${entry/LOCKED/UNLOCKED}/" "$achievements_file"
    done
}

# Function to update or add command usage
update_command_usage() {
    local command=$1
    local is_valid_command=$2

    # Set the command for awk processing
    export CMD="$command"
    
    # Update command usage count
    awk -F ':::' '
        BEGIN { cmd = ENVIRON["CMD"] }
        $0 ~ cmd ":::" {
            # Command found, increment count
            split($0, parts, ":::")
            count = parts[2] + 1
            print parts[1] ":::" count
            found = 1
            next
        }
        # Print all other lines unchanged
        { print }
        END {
            # If command not found, add it with count 1
            if (!found) print cmd ":::" 1
        }
    ' $used_commands_file > tmp && mv tmp $used_commands_file
  
    # Update EXP
    exp=$(get_exp)
    exp_increment=0
    local message=""
    
    if [ "$is_valid_command" = true ]; then
        if ! grep -Fq "$command:::" "$used_commands_file" || [ $(grep -F "$command:::" "$used_commands_file" | cut -d':' -f3) -le 1 ]; then
            exp_increment=$exp_new_command
            message="$msg_new_command"
            notify=$notify_on_new
        else
            exp_increment=$exp_reused_command
            message="$msg_repeat_command"
            notify=$notify_on_reused
        fi
    else
        if ! grep -Fq "$command:::" "$used_commands_file" || [ $(grep -F "$command:::" "$used_commands_file" | cut -d':' -f3) -le 1 ]; then
            exp_increment=$exp_false_new_command
            message="$msg_false_new_command"
            notify=$notify_on_false_new
        else
            exp_increment=$exp_false_reused_command
            message="$msg_false_repeat_command"
            notify=$notify_on_false_reused
        fi
    fi
    
    new_exp=$((exp + exp_increment))
    set_exp "$new_exp"
    
    # Update total commands
    total=$(grep "TOTAL_COMMANDS=" "$exp_file" | cut -d'=' -f2)
    total=$((total + 1))
    sed -i "s/^TOTAL_COMMANDS=.*/TOTAL_COMMANDS=$total/" "$exp_file"
  
    # If notification is enabled, print message
    if [ "$notify" = true ] && [ "$exp_increment" -gt 0 ]; then
        echo "$message"
        echo "Current EXP: $new_exp/$(exp_needed_for_level)"
    fi

    # Check for achievements
    check_achievements "$command"
    
    # Check for level up
    level_up
}

# Function to get the last command from history
get_last_command() {
    # This is a stub function that now calls getlastcommand for backwards compatibility
    getlastcommand
}

# Function to get the last command from the history file
getlastcommand() {
    local c
    case "$SHELL_NAME" in
        zsh)
            read -r c <<< "$(tail -n 1 $histfile | sed 's/\\n/\\\\n/g')"
            # Check for Zsh extended format
            if [[ "$c" == :* ]]; then
                # Strip the extended format: : timestamp:sequence;command
                c=$(echo "$c" | sed -e 's/^: [0-9]\+:[0-9]\+;//' -e 's/^[ \t]*//')
            fi
            printf '%s\n' "$c"
            ;;
        fish)
            # Fish history format is different, parse it
            # Format: - cmd: command\n  when: timestamp
            if [ -f "$histfile" ]; then
                # Find the most recent command by looking for "- cmd:" lines
                local cmd=$(grep -a "^- cmd:" "$histfile" | tail -n 1 | sed -E 's/^- cmd: (.*)/\1/')
                printf '%s\n' "$cmd"
            else
                printf '%s\n' ""
            fi
            ;;
        *pwsh*|*powershell*)
            # PowerShell history format handling
            if [ "$IS_POWERSHELL" = true ]; then
                # For PowerShell, we can try to get the last command directly from PowerShell
                if [ "$IS_WINDOWS" = true ]; then
                    # On Windows, use PowerShell to get the last command
                    # This is safer than trying to parse the history file directly
                    local cmd=$(powershell -NoProfile -Command "(Get-History -Count 1).CommandLine" 2>/dev/null)
                    printf '%s\n' "$cmd"
                else
                    # On Unix systems with PowerShell
                    if [ -f "$histfile" ]; then
                        # The history file exists, read the last line
                        local cmd=$(tail -n 1 "$histfile" 2>/dev/null)
                        printf '%s\n' "$cmd"
                    else
                        # Try to get it directly from PowerShell
                        local cmd=$(pwsh -NoProfile -Command "(Get-History -Count 1).CommandLine" 2>/dev/null)
                        printf '%s\n' "$cmd"
                    fi
                fi
            else
                # Fallback if PowerShell commands fail
                printf '%s\n' ""
            fi
            ;;
        *)
            # For bash and other shells
            if [ -f "$histfile" ]; then
                read -r c <<< "$(tail -n 1 $histfile)"
                printf '%s\n' "$c"
            else
                printf '%s\n' ""
            fi
            ;;
    esac
}

# Function to calculate date difference that works cross-platform
calculate_date_diff() {
    local date1="$1"  # format: YYYY-MM-DD
    local date2="$2"  # format: YYYY-MM-DD
    
    if [ "$IS_POWERSHELL" = true ] || [ "$IS_WINDOWS" = true ]; then
        # PowerShell/Windows approach
        powershell -NoProfile -Command "
            \$date1 = [datetime]::ParseExact('$date1', 'yyyy-MM-dd', \$null)
            \$date2 = [datetime]::ParseExact('$date2', 'yyyy-MM-dd', \$null)
            \$diff = \$date2 - \$date1
            Write-Output \$diff.Days
        "
    elif command -v gdate >/dev/null 2>&1; then
        # Use gdate if available (macOS with GNU utilities)
        local d1=$(gdate -d "$date1" +%s)
        local d2=$(gdate -d "$date2" +%s)
        echo $(( (d2 - d1) / 86400 ))
    else
        # Fallback for Unix systems without GNU date
        # Convert dates to seconds since epoch without -d option
        local IFS="-"
        read -r y1 m1 d1 <<< "$date1"
        read -r y2 m2 d2 <<< "$date2"
        
        # Use awk for date difference calculation
        awk -v y1="$y1" -v m1="$m1" -v d1="$d1" -v y2="$y2" -v m2="$m2" -v d2="$d2" '
        BEGIN {
            # Convert date to Julian day number
            # Algorithm from https://en.wikipedia.org/wiki/Julian_day
            jdn1 = (1461 * (y1 + 4800 + (m1 - 14)/12))/4 + (367 * (m1 - 2 - 12 * ((m1 - 14)/12)))/12 - (3 * ((y1 + 4900 + (m1 - 14)/12)/100))/4 + d1 - 32075
            jdn2 = (1461 * (y2 + 4800 + (m2 - 14)/12))/4 + (367 * (m2 - 2 - 12 * ((m2 - 14)/12)))/12 - (3 * ((y2 + 4900 + (m2 - 14)/12)/100))/4 + d2 - 32075
            print jdn2 - jdn1
        }'
    fi
}

# Function to update daily use streak
update_streak() {
    local current_date=$(crossplatform_date)
    local last_date_used=$(grep "last_date_used=" "$streak_file" | cut -d'=' -f2)
    local streak=$(grep "streak=" "$streak_file" | cut -d'=' -f2)

    # Check if the script is used on the next day
    if [ "$current_date" != "$last_date_used" ]; then
        local day_diff=$(calculate_date_diff "$last_date_used" "$current_date")

        if [ "$day_diff" -eq 1 ]; then
            # Increment streak if the script was used on the next day
            streak=$((streak + 1))
        else
            # Reset streak if a day was skipped
            streak=1
        fi

        # Update .streak file
        sed -i "s/^last_date_used=.*/last_date_used=$current_date/" "$streak_file"
        sed -i "s/^streak=.*/streak=$streak/" "$streak_file"
    fi
}

# Checks the current level
checkrank() {
    local level=$(get_lvl)
    local exp=$(get_exp)
    local needed=$(exp_needed_for_level)
    local rank=$(get_rank "$level")
    local rank_padding_left=$(( (26 - ${#rank}) / 2 ))
    local rank_padding_right=$(( 26 - ${#rank} - rank_padding_left ))
    local rank_line="||$(printf '%*s' $rank_padding_left) $rank $(printf '%*s' $rank_padding_right)||"
    local exp_padding_left=$(( (26 - ${#exp} - ${#needed} - 6) / 2 ))
    local exp_padding_right=$(( 26 - ${#exp} - ${#needed} - 6 - exp_padding_left ))
    local exp_line="||$(printf '%*s' "$exp_padding_left") EXP: $exp/$needed $(printf '%*s' "$exp_padding_right")||"
    local quote=$(get_quote "$level")

    printf "\n================================\n"
    printf "||       CURRENT LEVEL        ||\n"
    printf "||         Level: %-5s       ||\n" "$level"
    printf "%s\n" "$exp_line"
    printf "%s\n" "$rank_line"
    printf "================================\n"
    show_exp_progress
    printf "================================\n"
    printf "%s\n" "$quote"
    printf "================================\n\n"
}

# Level-up message
level_up_message() {
    local level=$1
    local rank=$(get_rank "$level")
    local rank_padding_left=$(( (26 - ${#rank}) / 2 ))
    local rank_padding_right=$(( 26 - ${#rank} - rank_padding_left ))
    local rank_line="||$(printf '%*s' $rank_padding_left) $rank $(printf '%*s' $rank_padding_right)||"
    local quote=$(get_quote "$level")

    printf "\n================================\n"
    printf "||          LEVEL UP!         ||\n"
    printf "||    You reached level %-5s ||\n" "$level"
    printf "%s\n" "$rank_line"
    printf "||                            ||\n"
    printf "||   ░░░░░░░░░▄▄▄▄▄░░░░░░░░   ||\n"
    printf "||   ░░░░░▄██████████▄░░░░░   ||\n"
    printf "||   ░░░▄██████████████▄░░░   ||\n"
    printf "================================\n"
    printf "%s\n" "$quote"
    printf "================================\n\n"
}

# Displays exp progress bar
show_exp_progress() {
  local exp=$(get_exp)
  local needed=$(exp_needed_for_level)
  local progress=$((exp * 30 / needed))
  printf "[%-30s] \n" "$(printf '#%.0s' $(seq 1 $progress))"
}

# Level-up ranks
get_rank() {
    local lvl=$1
    case $lvl in
        [1-4]) echo "Terminal Newbie" ;;
        [5-9]) echo "Script Kiddie" ;;
        1[0-4]) echo "Command Line Enthusiast" ;;
        1[5-9]) echo "Shell Apprentice" ;;
        2[0-4]) echo "Daemon Handler" ;;
        2[5-9]) echo "System Sorcerer" ;;
        3[0-9]) echo "Unix Warrior" ;;
        4[0-9]) echo "Pipe Artisan" ;;
        5[0-9]) echo "Network Nomad" ;;
        6[0-9]) echo "Bash Wizard" ;;
        7[0-9]) echo "Shell Savant" ;;
        8[0-9]) echo "Linux Warlock" ;;
        9[0-9]) echo "Archmage of the CLI" ;;
        *) echo "Root God" ;;
    esac
}

# rank quotes
get_quote() {
    local lvl=$1
    case $lvl in
        [1-4]) printf -- "  -\"Wait, how do I exit Vim?\"" ;;
        [5-9]) printf -- "  -\"I copied this from Stack \n    Overflow… hope it works.\"" ;;
        1[0-4]) printf -- "  -\"I run htop just to watch \n    the colors.\"" ;;
        1[5-9]) printf -- " -\"My .bashrc is literal art.\"" ;;
        2[0-4]) printf -- "  -\"I made a service… and it \n    stays running!\"" ;;
        2[5-9]) printf -- "  -\"My one-liner fixed your \n    DNS, and brewed coffee.\"" ;;
        3[0-9]) printf -- "  -\"I herd servers like cats.\"" ;;
        4[0-9]) printf -- "    -\"My scripts have error\n    handling… and comments.\"" ;;
        5[0-9]) printf -- "  -\"I SSH through three hops\n    just to say 'hi'.\"" ;;
        6[0-9]) printf -- "  -\"I see regex in my sleep.\"" ;;
        7[0-9]) printf -- "   -\"I use vi to edit emacs\n       configs. Fight me.\"" ;;
        8[0-9]) printf -- "    -\"I filed a bug report…\n       and then fixed it.\"" ;;
        9[0-9]) printf -- "  -\"I speak in ANSI escape\n    codes and dream in JSON.\"" ;;
        *) printf -- "       -\"/dev/null is my\n         recycling bin.\"" ;;
    esac
}

# Function to display stats
checkstats() {
    local total_commands=$(grep "TOTAL_COMMANDS=" "$exp_file" | cut -d'=' -f2)
    local most_used_command=$(awk -F ':::' '{if($2 > max){max=$2; cmd=$1}} END {print cmd " (" max " times)"}' "$used_commands_file")
    local unique_commands=$(wc -l < "$used_commands_file")

    local unlocked_count=$(grep -c ":UNLOCKED" "$achievements_file")
    local total_count=$(wc -l < "$achievements_file")
    local streak=$(grep "streak=" "$streak_file" | cut -d'=' -f2)

    echo "Current Streak: $streak days"
    echo "Unique Commands Used: $unique_commands"
    echo "Total Commands Used: $total_commands"
    echo "Most Used Command: ${most_used_command:-None yet}"
    echo ""
    echo "Achievements Unlocked ($unlocked_count/$total_count):"
    grep ":UNLOCKED" "$achievements_file" | awk -F ':' '{print "✔ " $1 " - " $2}'
}

# Displays help information
ghelp() {
    cat <<EOF

# =============================
# Linux Terminal Gamifier v1.6
# =============================
# This script gamifies your terminal by tracking experience points and levels
# based on the number of commands you execute. Newly found commands give more exp,
# repeated commands less, wrong commands still give a little. At least you tried.
#
# You can use checkrank at any time to check your current progress.
# Use checkstats to display usage stats.
# Use ghelp to display a short info message.
# Use gupdate to update Linux Terminal Gamifier.

EOF
}

# Updates the gamifier script
gupdate()
{
 local current_version remote_version

    # Extract the current version from this script
    current_version=$(grep -oP '(?<=# Linux Terminal Gamifier v)\d+\.\d+' $HOME/gamifier | head -n 1)

    # Fetch the latest version from GitHub
    remote_version=$(curl -s "https://raw.githubusercontent.com/Divinux/linux-terminal-gamifier/main/gamifier" | grep -oP '(?<=# Linux Terminal Gamifier v)\d+\.\d+' | head -n 1)
    if [[ -z "$remote_version" ]]; then
        echo "Failed to fetch remote version."
        return 1
    fi

    if [[ "$current_version" != "$remote_version" ]]; then
        echo "New version available: v$remote_version (current: v$current_version). Updating..."
        curl --output $HOME/gamifier "https://raw.githubusercontent.com/Divinux/linux-terminal-gamifier/refs/heads/main/gamifier"
        # Use the appropriate source command based on shell
        if [ "$IS_POWERSHELL" = true ]; then
            . $HOME/gamifier
        else
            source $HOME/gamifier
        fi
        echo "Update complete!"
    else
        echo "Linux Terminal Gamifier is up to date. (v$current_version)."
    fi
updateachievementlist
}

updateachievementlist()
{
    local new_achievements existing_achievements
    # Extract achievements from the new local script
    new_achievements=$(grep -oP '^\S.*:.*:.*:LOCKED$' "${HOME}/gamifier")

    # Load existing achievements (including unlocked ones)
    existing_achievements=$(cat "${achievements_file}")

    # Loop through new achievements and check if they already exist based on their name
    while IFS= read -r new_achievement; do
        new_achievement_name=$(echo "${new_achievement}" | cut -d: -f1)  # Get the achievement name before the first colon
        if ! echo "${existing_achievements}" | grep -q "^${new_achievement_name}:"; then
            echo "${new_achievement}" >> "${achievements_file}"
        fi
    done <<< "${new_achievements}"
}

# PowerShell compatibility functions
# These functions provide alternatives to common Unix commands when running in PowerShell

# Check for command name conflicts in PowerShell
check_powershell_command_conflicts() {
    if [ "$IS_POWERSHELL" = true ]; then
        local conflict_found=false
        local conflicting_commands=""
        
        # List of our commands that might conflict
        local our_commands=("checkrank" "checkstats" "ghelp" "gupdate")
        
        # Check each command for conflicts
        for cmd in "${our_commands[@]}"; do
            # Use Get-Command to check if command exists in PowerShell
            local cmd_exists=$(powershell -NoProfile -Command "if(Get-Command $cmd -ErrorAction SilentlyContinue){Write-Output 'exists'}" 2>/dev/null)
            if [ "$cmd_exists" = "exists" ]; then
                conflict_found=true
                conflicting_commands="$conflicting_commands $cmd"
            fi
        done
        
        # If conflicts were found, create aliases with ltg_ prefix
        if [ "$conflict_found" = true ]; then
            echo "Warning: Some Linux Terminal Gamifier commands conflict with existing PowerShell commands: $conflicting_commands"
            echo "Creating alternative command aliases with 'ltg_' prefix."
            
            # Create aliases for our commands
            if [[ "$conflicting_commands" == *"checkrank"* ]]; then
                alias ltg_checkrank=checkrank
                echo "Use 'ltg_checkrank' instead of 'checkrank'"
            fi
            
            if [[ "$conflicting_commands" == *"checkstats"* ]]; then
                alias ltg_checkstats=checkstats
                echo "Use 'ltg_checkstats' instead of 'checkstats'"
            fi
            
            if [[ "$conflicting_commands" == *"ghelp"* ]]; then
                alias ltg_ghelp=ghelp
                echo "Use 'ltg_ghelp' instead of 'ghelp'"
            fi
            
            if [[ "$conflicting_commands" == *"gupdate"* ]]; then
                alias ltg_gupdate=gupdate
                echo "Use 'ltg_gupdate' instead of 'gupdate'"
            fi
        fi
    fi
}

# Safe sed replacement for PowerShell
powershell_sed() {
    if [ "$IS_POWERSHELL" = true ]; then
        local pattern="$1"
        local input="$2"
        if [ -n "$input" ]; then
            printf "%s" "$input" | powershell -NoProfile -Command "Get-Content -Raw -Path 'Console' | ForEach-Object { `$_ -replace '$pattern' }"
        else
            powershell -NoProfile -Command "Get-Content -Raw -Path 'Console' | ForEach-Object { `$_ -replace '$pattern' }"
        fi
    else
        sed "$1" <<<"$2"
    fi
}

# Safe grep replacement for PowerShell
powershell_grep() {
    if [ "$IS_POWERSHELL" = true ]; then
        # Use PowerShell's Select-String
        local pattern="$1"
        local file="$2"
        if [ -n "$file" ] && [ -f "$file" ]; then
            powershell -NoProfile -Command "Select-String -Pattern '$pattern' -Path '$file' | ForEach-Object { \$_.Line }"
        else
            # Read from stdin if no file is provided
            powershell -NoProfile -Command "Select-String -Pattern '$pattern'"
        fi
    else
        # Fall back to regular grep if not in PowerShell
        if [ -n "$2" ]; then
            grep "$1" "$2"
        else
            grep "$1"
        fi
    fi
}

# File existence check that works in both environments
file_exists() {
    if [ "$IS_POWERSHELL" = true ]; then
        powershell -NoProfile -Command "Test-Path -Path '$1'" | grep -q "True"
    else
        [ -f "$1" ]
    fi
}

# Directory existence check that works in both environments
dir_exists() {
    if [ "$IS_POWERSHELL" = true ]; then
        powershell -NoProfile -Command "Test-Path -Path '$1' -PathType Container" | grep -q "True"
    else
        [ -d "$1" ]
    fi
}

# Create a directory in a cross-platform way
create_dir() {
    if [ "$IS_POWERSHELL" = true ]; then
        powershell -NoProfile -Command "New-Item -ItemType Directory -Force -Path '$1'" > /dev/null
    else
        mkdir -p "$1"
    fi
}

# Write to a file in a cross-platform way
write_file() {
    local file="$1"
    local content="$2"
    
    if [ "$IS_POWERSHELL" = true ]; then
        # Escape single quotes in the content for PowerShell
        content=$(echo "$content" | sed "s/'/''/g")
        powershell -NoProfile -Command "Set-Content -Path '$file' -Value '$content'"
    else
        echo "$content" > "$file"
    fi
}

# Append to a file in a cross-platform way
append_file() {
    local file="$1"
    local content="$2"
    
    if [ "$IS_POWERSHELL" = true ]; then
        # Escape single quotes in the content for PowerShell
        content=$(echo "$content" | sed "s/'/''/g")
        powershell -NoProfile -Command "Add-Content -Path '$file' -Value '$content'"
    else
        echo "$content" >> "$file"
    fi
}

crossplatform_date() {
    if [ "$IS_WINDOWS" = true ]; then
        powershell -Command "Get-Date -Format 'yyyy-MM-dd'"
    else
        date +%Y-%m-%d
    fi
}

# Check PowerShell execution policy and suggest solution
check_powershell_execution_policy() {
    if [ "$IS_POWERSHELL" = true ]; then
        local current_policy=$(powershell -NoProfile -Command "Get-ExecutionPolicy" 2>/dev/null)
        
        if [ "$current_policy" = "Restricted" ]; then
            echo "Warning: PowerShell execution policy is set to 'Restricted'"
            echo "This prevents running scripts. To fix this, you can:"
            echo "1. Run PowerShell as Administrator and execute:"
            echo "   Set-ExecutionPolicy RemoteSigned -Scope CurrentUser"
            echo "2. Or use this one-liner (requires admin rights):"
            echo "   Start-Process powershell -Verb RunAs -ArgumentList 'Set-ExecutionPolicy RemoteSigned -Scope CurrentUser'"
            echo ""
            echo "After changing the policy, you'll need to:"
            echo "1. Close and reopen PowerShell"
            echo "2. Run: . $PROFILE"
            echo ""
            echo "Note: RemoteSigned allows local scripts to run without signing, but requires downloaded scripts to be signed by a trusted publisher."
        fi
    fi
}

# Cross-platform replacement for sed -i
crossplatform_sed_inplace() {
    local pattern="$1"
    local file="$2"
    
    if [ "$IS_POWERSHELL" = true ]; then
        # PowerShell implementation
        powershell -NoProfile -Command "(Get-Content -Path '$file') | ForEach-Object { `$_ -replace '$pattern' } | Set-Content -Path '$file'"
    elif [ "$(uname)" = "Darwin" ]; then
        # macOS requires empty extension for -i
        sed -i '' "$pattern" "$file"
    else
        # Linux and other systems
        sed -i "$pattern" "$file"
    fi
}

# Normalizing paths for Windows
normalize_path() {
    local path="$1"
    
    if [ "$IS_WINDOWS" = true ]; then
        # Replace / with \ for Windows
        echo "$path" | sed 's|/|\\|g'
    else
        # Keep as is for Unix
        echo "$path"
    fi
}
